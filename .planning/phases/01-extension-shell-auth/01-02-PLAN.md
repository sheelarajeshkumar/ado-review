---
phase: 01-extension-shell-auth
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - entrypoints/ado-pr.content/index.tsx
  - entrypoints/ado-pr.content/App.tsx
  - entrypoints/ado-pr.content/style.css
  - entrypoints/ado-pr.content/components/ReviewButton.tsx
autonomous: true

must_haves:
  truths:
    - "Content script activates on any dev.azure.com page"
    - "Review button appears only on PR URLs, not on other Azure DevOps pages"
    - "Review button re-appears after SPA navigation to a different PR"
    - "Review button disappears when navigating away from a PR page"
    - "Only one review button exists at a time (no duplicates after navigation)"
    - "Review button is visually isolated from Azure DevOps styles via Shadow DOM"
  artifacts:
    - path: "entrypoints/ado-pr.content/index.tsx"
      provides: "Content script entrypoint with SPA navigation handling"
      contains: "defineContentScript"
    - path: "entrypoints/ado-pr.content/App.tsx"
      provides: "React root component receiving prInfo"
      contains: "prInfo"
    - path: "entrypoints/ado-pr.content/components/ReviewButton.tsx"
      provides: "Review button React component"
      min_lines: 15
    - path: "entrypoints/ado-pr.content/style.css"
      provides: "Scoped styles for shadow root UI"
      min_lines: 5
  key_links:
    - from: "entrypoints/ado-pr.content/index.tsx"
      to: "lib/url-matcher.ts"
      via: "imports isPullRequestUrl and parsePrUrl for URL detection"
      pattern: "import.*isPullRequestUrl.*from.*@/lib/url-matcher"
    - from: "entrypoints/ado-pr.content/index.tsx"
      to: "lib/selectors.ts"
      via: "imports SELECTORS for anchor element discovery"
      pattern: "import.*SELECTORS.*from.*@/lib/selectors"
    - from: "entrypoints/ado-pr.content/index.tsx"
      to: "wxt:locationchange"
      via: "ctx.addEventListener for SPA navigation"
      pattern: "wxt:locationchange"
    - from: "entrypoints/ado-pr.content/index.tsx"
      to: "createShadowRootUi"
      via: "WXT shadow DOM injection"
      pattern: "createShadowRootUi"
    - from: "entrypoints/ado-pr.content/App.tsx"
      to: "shared/types.ts"
      via: "receives PrInfo prop"
      pattern: "import.*PrInfo.*from.*@/shared/types"
---

<objective>
Create the content script that injects a review button into Azure DevOps PR pages and handles SPA navigation.

Purpose: This is the user-facing core of Phase 1 -- the review button that appears on PR pages. It must activate on the right URLs, inject into the right place in the DOM, survive SPA navigation, and clean up when leaving PR pages.
Output: A content script with Shadow DOM-isolated React review button that responds to SPA navigation.
</objective>

<execution_context>
@/Users/81169560/.claude/get-shit-done/workflows/execute-plan.md
@/Users/81169560/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-extension-shell-auth/01-RESEARCH.md
@.planning/phases/01-extension-shell-auth/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content script entrypoint with SPA navigation and Shadow DOM injection</name>
  <files>
    entrypoints/ado-pr.content/index.tsx
    entrypoints/ado-pr.content/style.css
  </files>
  <action>
    Create `entrypoints/ado-pr.content/index.tsx` following the exact pattern from 01-RESEARCH.md "Complete Content Script Entry Point" example.

    The content script must:

    1. **Match broadly:** `matches: ['*://dev.azure.com/*']` -- this ensures the content script loads on ANY Azure DevOps page, so SPA navigation from non-PR pages to PR pages works. Do NOT use a narrow PR-only pattern (see Pitfall 4 in research).

    2. **Use `cssInjectionMode: 'ui'`** so styles are injected into the shadow root, not the page.

    3. **Track current UI instance** in a module-level variable `let currentUi: ... | null = null` to prevent duplicate buttons.

    4. **On initial load:** Check `isPullRequestUrl(window.location.href)`. If true, call `tryMount(ctx)`.

    5. **On SPA navigation:** Listen for `wxt:locationchange` via `ctx.addEventListener(window, 'wxt:locationchange', handler)`. The handler receives `{ newUrl, oldUrl }`. Logic:
       - If navigating TO a PR page: remove existing UI if any, then mount new button
       - If navigating AWAY from a PR page: remove existing UI
       - If navigating BETWEEN PRs: remove existing UI, mount new one (different PR context)

    6. **`tryMount(ctx)` function:**
       - Import and use `waitForElement` from `@/lib/selectors` (created in Plan 01) to wait for the PR header anchor element. Use `SELECTORS.PR_HEADER_ACTIONS` with a 5000ms timeout.
       - If anchor not found, log a warning and return (don't crash).
       - Parse the current URL with `parsePrUrl(window.location.href)` to get `PrInfo`.
       - Use `createShadowRootUi(ctx, {...})` with:
         - `name: 'pep-review-button'`
         - `position: 'inline'`
         - `anchor` set to the found element
         - `onMount`: create a div wrapper, create React root, render `<App prInfo={prInfo} />`
         - `onRemove`: unmount React root
       - Call `ui.mount()` and store in `currentUi`.

    7. **Cleanup:** When removing UI, call `currentUi.remove()` and set to null.

    Create `entrypoints/ado-pr.content/style.css` with minimal base styles:
    - Reset box-sizing for the shadow root container
    - Set font-family to match Azure DevOps (Segoe UI, sans-serif)
    - Style the review button: blue/teal background (#0078d4 -- Azure DevOps accent color), white text, rounded corners (4px), padding (6px 12px), cursor pointer, hover state (slightly darker), no border
    - Keep styles minimal -- this is a single button, not a complex UI

    IMPORTANT: Use `ctx.addEventListener` (not `window.addEventListener`) to ensure listeners are cleaned up when the extension context is invalidated. Use `ctx.setTimeout` (not `setTimeout`) for the same reason.
  </action>
  <verify>
    Run `npm run build` -- build succeeds with no errors.
    Run `npx tsc --noEmit` -- TypeScript compiles cleanly.
    Check the built manifest at `.output/chrome-mv3/manifest.json` -- it should contain a `content_scripts` entry matching `*://dev.azure.com/*`.
  </verify>
  <done>
    Content script entrypoint exists and compiles. It matches `*://dev.azure.com/*`, listens for `wxt:locationchange`, conditionally mounts/unmounts the review button based on URL, uses Shadow DOM via `createShadowRootUi`, tracks current UI to prevent duplicates, and waits for DOM elements with MutationObserver timeout.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ReviewButton and App React components</name>
  <files>
    entrypoints/ado-pr.content/App.tsx
    entrypoints/ado-pr.content/components/ReviewButton.tsx
  </files>
  <action>
    Create `entrypoints/ado-pr.content/App.tsx`:
    - Accept `prInfo: PrInfo` as a prop (import from `@/shared/types`)
    - Render `<ReviewButton prInfo={prInfo} />`
    - This is a thin wrapper that will grow in later phases (progress UI, error states)

    Create `entrypoints/ado-pr.content/components/ReviewButton.tsx`:
    - Accept `prInfo: PrInfo` as a prop
    - Render a button element with:
      - Text: "PEP Review" (with a small code review icon -- use unicode or SVG inline, not an icon library)
      - CSS class `pep-review-btn` (styled in style.css)
      - `onClick` handler that:
        1. Sends a `CHECK_AUTH` message to the background script via `sendMessage('CHECK_AUTH', { orgUrl: prInfo.baseUrl })`
        2. Logs the auth result to console for now (actual review pipeline is Phase 2)
        3. Shows a simple visual feedback: button text changes to "Checking..." while waiting, then either "Authenticated (session)" or "Authenticated (PAT)" or "Not authenticated" for 2 seconds, then reverts to "PEP Review"
    - Use React useState for button state: `'idle' | 'checking' | 'authenticated' | 'unauthenticated'`
    - Display auth method in the feedback (session vs PAT)

    This button is intentionally simple -- Phase 2 will add the review trigger. For Phase 1, clicking the button verifies that:
    1. The button is injected and clickable
    2. Message passing to the background script works
    3. Auth check returns a meaningful result

    Do NOT add:
    - Loading spinners or complex animations
    - Error modals or toast notifications
    - Any review-triggering logic (that's Phase 2)
  </action>
  <verify>
    Run `npm run build` -- build succeeds.
    Run `npx tsc --noEmit` -- compiles cleanly.
    Verify the component imports resolve: `@/shared/types` for PrInfo, `@/shared/messages` for sendMessage.
  </verify>
  <done>
    App.tsx renders ReviewButton with prInfo. ReviewButton shows "PEP Review" text, sends CHECK_AUTH message on click, shows auth status feedback. Both components compile and are rendered inside the shadow root by the content script.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `.output/chrome-mv3/manifest.json` has content_scripts entry for `*://dev.azure.com/*`
3. Content script imports from lib/url-matcher.ts and lib/selectors.ts compile correctly
4. ReviewButton component sends CHECK_AUTH message via typed sendMessage
5. No duplicate UI creation logic -- currentUi is tracked and removed before re-mounting
</verification>

<success_criteria>
- Content script activates on all dev.azure.com pages (broad match)
- Button injection uses createShadowRootUi with Shadow DOM isolation
- SPA navigation handled via wxt:locationchange with proper mount/unmount lifecycle
- waitForElement polls for anchor with MutationObserver and 5s timeout
- ReviewButton displays, is clickable, and sends CHECK_AUTH message to background
- No duplicate buttons after repeated navigation
</success_criteria>

<output>
After completion, create `.planning/phases/01-extension-shell-auth/01-02-SUMMARY.md`
</output>
