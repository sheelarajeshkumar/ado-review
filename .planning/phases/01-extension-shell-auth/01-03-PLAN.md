---
phase: 01-extension-shell-auth
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/auth/session.ts
  - lib/auth/pat.ts
  - lib/auth/manager.ts
  - entrypoints/background.ts
  - entrypoints/options/index.html
  - entrypoints/options/main.tsx
  - entrypoints/options/App.tsx
  - entrypoints/options/style.css
  - entrypoints/popup/index.html
  - entrypoints/popup/main.tsx
  - entrypoints/popup/App.tsx
autonomous: true

must_haves:
  truths:
    - "Background service worker receives CHECK_AUTH messages and returns auth status"
    - "Session auth tests against _apis/connectionData with credentials:'include'"
    - "PAT auth uses Basic header with base64(':' + pat) encoding"
    - "Auth manager tries session first, falls back to PAT"
    - "Options page allows user to enter and save a PAT"
    - "PAT is validated against Azure DevOps before storing"
    - "Invalid PAT shows error message to user"
    - "Popup shows current auth status"
  artifacts:
    - path: "lib/auth/manager.ts"
      provides: "Auth orchestration: session-first with PAT fallback"
      exports: ["getAuthHeaders", "checkAuth"]
    - path: "lib/auth/session.ts"
      provides: "Session cookie auth via service worker fetch"
      exports: ["testSessionAuth", "sessionFetch"]
    - path: "lib/auth/pat.ts"
      provides: "PAT storage, validation, and header generation"
      exports: ["tryPatAuth", "validatePatFormat", "testPat"]
    - path: "entrypoints/background.ts"
      provides: "Service worker with message handler registry"
      contains: "defineBackground"
    - path: "entrypoints/options/App.tsx"
      provides: "Options page with PAT entry form"
      contains: "SAVE_PAT"
    - path: "entrypoints/popup/App.tsx"
      provides: "Popup showing auth status"
      contains: "CHECK_AUTH"
  key_links:
    - from: "entrypoints/background.ts"
      to: "lib/auth/manager.ts"
      via: "calls checkAuth on CHECK_AUTH message"
      pattern: "import.*checkAuth.*from.*@/lib/auth/manager"
    - from: "lib/auth/manager.ts"
      to: "lib/auth/session.ts"
      via: "tries session auth first"
      pattern: "import.*testSessionAuth.*from.*@/lib/auth/session"
    - from: "lib/auth/manager.ts"
      to: "lib/auth/pat.ts"
      via: "falls back to PAT auth"
      pattern: "import.*tryPatAuth.*from.*@/lib/auth/pat"
    - from: "lib/auth/session.ts"
      to: "dev.azure.com/_apis/connectionData"
      via: "fetch with credentials:'include'"
      pattern: "credentials.*include"
    - from: "lib/auth/pat.ts"
      to: "shared/storage.ts"
      via: "reads/writes PAT from chrome.storage.local"
      pattern: "import.*from.*@/shared/storage"
    - from: "entrypoints/options/App.tsx"
      to: "shared/messages.ts"
      via: "sends SAVE_PAT message to background"
      pattern: "sendMessage.*SAVE_PAT"
    - from: "entrypoints/background.ts"
      to: "lib/auth/pat.ts"
      via: "validates and stores PAT on SAVE_PAT message"
      pattern: "validatePatFormat|testPat"
---

<objective>
Create the authentication system (session cookies + PAT fallback) with background service worker and options page for PAT entry.

Purpose: This is the auth backbone of the extension. The review button (Plan 02) sends CHECK_AUTH messages that this service worker handles. The options page gives users a way to enter a PAT when session auth fails. Without this, the extension cannot make authenticated Azure DevOps API calls.
Output: Auth module with session-first/PAT-fallback strategy, background service worker with message handling, options page for PAT management, popup showing auth status.
</objective>

<execution_context>
@/Users/81169560/.claude/get-shit-done/workflows/execute-plan.md
@/Users/81169560/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-extension-shell-auth/01-RESEARCH.md
@.planning/phases/01-extension-shell-auth/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth module with session-first and PAT fallback strategy</name>
  <files>
    lib/auth/session.ts
    lib/auth/pat.ts
    lib/auth/manager.ts
  </files>
  <action>
    Create `lib/auth/session.ts`:
    - Export `testSessionAuth(orgUrl: string): Promise<boolean>`:
      - Makes GET request to `${orgUrl}/_apis/connectionData`
      - MUST use `credentials: 'include'` on the fetch call (see Pitfall 1 in research -- cookies are NOT sent automatically from service workers)
      - Include `Accept: application/json` header
      - Returns `true` if response.ok, `false` otherwise
      - Wraps in try/catch, returns `false` on network errors
    - Export `sessionFetch(url: string, options?: RequestInit): Promise<Response>`:
      - Wraps fetch with `credentials: 'include'` always set
      - Merges `Accept: application/json` into headers
      - This is the function all Azure DevOps API calls will use when session-authenticated

    Create `lib/auth/pat.ts`:
    - Import `getPat`, `setPat`, `clearPat` from `@/shared/storage`
    - Import `PAT_LENGTH`, `CONNECTION_DATA_PATH` from `@/shared/constants`
    - Export `validatePatFormat(pat: string): { valid: boolean; error?: string }`:
      - Check length is PAT_LENGTH (84 characters)
      - Check it doesn't contain whitespace
      - Return `{ valid: true }` or `{ valid: false, error: '...' }`
    - Export `testPat(pat: string, orgUrl?: string): Promise<{ valid: boolean; error?: string }>`:
      - Makes GET request to `${orgUrl || 'https://dev.azure.com'}/_apis/connectionData`
      - Uses `Authorization: Basic ${btoa(':' + pat)}` header
      - Returns `{ valid: true }` if response.ok
      - Returns `{ valid: false, error: 'PAT rejected by Azure DevOps (HTTP {status})' }` otherwise
    - Export `tryPatAuth(): Promise<{ method: 'pat'; headers: Record<string, string> } | null>`:
      - Reads stored PAT via `getPat()`
      - If no PAT stored, return null
      - Returns `{ method: 'pat', headers: { Authorization: 'Basic ...' } }`
      - Does NOT re-validate the PAT on every call (validation happens on save)
    - Export `savePat(pat: string, orgUrl?: string): Promise<{ success: boolean; error?: string }>`:
      - Validates format with `validatePatFormat`
      - If format invalid, return error
      - Tests against Azure DevOps with `testPat`
      - If test fails, return error
      - If all good, store via `setPat` and return success

    Create `lib/auth/manager.ts`:
    - Import from session.ts and pat.ts
    - Import `AuthMethod`, `AuthStatus` from `@/shared/types`
    - Export `checkAuth(orgUrl: string): Promise<AuthStatus>`:
      - Try `testSessionAuth(orgUrl)` first
      - If session works: return `{ authenticated: true, method: 'session' }`
      - If session fails: try `tryPatAuth()`
      - If PAT available: return `{ authenticated: true, method: 'pat' }`
      - If nothing: return `{ authenticated: false, method: 'none' }`
    - Export `getAuthHeaders(orgUrl: string): Promise<{ method: AuthMethod; headers: Record<string, string> } | null>`:
      - Same cascade: session first (empty headers, cookies do the work), then PAT (Authorization header)
      - Returns null if no auth available

    CRITICAL: All fetch calls to dev.azure.com from the service worker MUST include `credentials: 'include'`. This is the #1 pitfall identified in research.

    Do NOT store any state in module-level variables in auth files -- the service worker can terminate and restart. All persistent state goes through chrome.storage via the shared/storage helpers.
  </action>
  <verify>
    Run `npx tsc --noEmit` -- all auth files compile cleanly.
    Run `npm run build` -- build succeeds.
    Verify import chain: manager.ts -> session.ts, manager.ts -> pat.ts, pat.ts -> shared/storage.ts.
  </verify>
  <done>
    Three auth files exist and compile. Session auth uses credentials:'include' on every fetch. PAT auth validates format (84 chars) and tests against connectionData endpoint before storing. Manager orchestrates session-first, PAT-fallback cascade. No module-level state in any auth file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create background service worker, options page for PAT entry, and popup for auth status</name>
  <files>
    entrypoints/background.ts
    entrypoints/options/index.html
    entrypoints/options/main.tsx
    entrypoints/options/App.tsx
    entrypoints/options/style.css
    entrypoints/popup/index.html
    entrypoints/popup/main.tsx
    entrypoints/popup/App.tsx
  </files>
  <action>
    Create `entrypoints/background.ts`:
    - Use `defineBackground(() => { ... })` from WXT
    - Set up a message handler registry pattern (not a giant switch statement):
      ```
      const handlers: Record<string, Function> = {
        CHECK_AUTH: handleCheckAuth,
        SAVE_PAT: handleSavePat,
      };
      ```
    - Register `chrome.runtime.onMessage.addListener` that dispatches to handlers
    - Return `true` from the listener to keep the channel open for async responses
    - `handleCheckAuth(payload: { orgUrl: string })`: calls `checkAuth(orgUrl)` from auth/manager and returns the AuthStatus
    - `handleSavePat(payload: { pat: string })`: calls `savePat(pat)` from auth/pat and returns success/error

    Create options page (`entrypoints/options/`):
    - `index.html`: Basic HTML shell with div#root, title "PEP Review Settings"
    - `main.tsx`: Renders App into #root
    - `App.tsx`: A form with:
      - Heading: "PEP Review Settings"
      - Subheading: "Azure DevOps Authentication"
      - Explanation text: "The extension first tries to use your browser session. If that doesn't work, enter a Personal Access Token below."
      - Current auth status display: On mount, send CHECK_AUTH message, show "Session active", "Using PAT", or "Not authenticated" with appropriate color (green/yellow/red)
      - PAT input field: `type="password"`, placeholder "Enter your Azure DevOps PAT"
      - Save button: Sends SAVE_PAT message to background, shows success or error feedback inline (not an alert)
      - Clear PAT button: Calls clearPat() from storage helpers, updates status display
      - All form interactions should be disabled while an operation is in progress
    - `style.css`: Clean, simple form styles. Use system font stack. Max-width 600px centered. Form group spacing. Input/button styles matching Azure DevOps aesthetic (blue accent #0078d4). Success = green, error = red, warning = yellow feedback colors.

    Create popup (`entrypoints/popup/`):
    - `index.html`: Basic HTML shell with div#root, title "PEP Review"
    - `main.tsx`: Renders App into #root
    - `App.tsx`: Minimal popup showing:
      - Extension name "PEP Review"
      - Auth status indicator (green dot + "Connected" / yellow dot + "PAT" / red dot + "Not connected")
      - On mount: send CHECK_AUTH message with a default orgUrl (https://dev.azure.com) -- this is a quick status check
      - Link to options page: `chrome.runtime.openOptionsPage()` on click
      - Fixed width ~300px, clean layout

    For both options and popup, use the standard WXT file-based entrypoint pattern. WXT will auto-generate manifest entries for these.

    IMPORTANT for background.ts:
    - Do NOT use global variables for state. Service workers terminate.
    - Do NOT use setTimeout/setInterval. Use chrome.alarms if timers are needed (not needed in Phase 1).
    - The message listener MUST return `true` for async handlers.
  </action>
  <verify>
    Run `npm run build` -- build succeeds.
    Run `npx tsc --noEmit` -- compiles cleanly.
    Check `.output/chrome-mv3/manifest.json` contains:
    - `background.service_worker` entry
    - `options_page` or `options_ui` entry
    - `action.default_popup` entry
    Verify message flow: options sends SAVE_PAT -> background receives -> calls savePat -> responds.
  </verify>
  <done>
    Background service worker handles CHECK_AUTH and SAVE_PAT messages via handler registry. Options page has PAT entry form with validation feedback and auth status display. Popup shows current auth status with colored indicator and link to options. All entrypoints compile and appear in the built manifest.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with no errors
2. Built manifest contains background service worker, content script, options page, and popup entries
3. Auth cascade: session (credentials:'include') -> PAT (Basic header) -> null
4. PAT validation: format check (84 chars) + live test against connectionData endpoint
5. Message passing: content script/popup -> CHECK_AUTH -> background -> auth/manager -> response
6. Options page: PAT entry -> SAVE_PAT -> background -> validate -> store -> feedback
7. No module-level state in service worker or auth modules
</verification>

<success_criteria>
- Session auth tests against _apis/connectionData with credentials:'include'
- PAT validated before storage (format + live test)
- Background service worker dispatches messages to typed handlers
- Options page provides PAT entry with success/error feedback
- Popup shows auth status at a glance
- All auth state persisted via chrome.storage.local (no module-level state)
</success_criteria>

<output>
After completion, create `.planning/phases/01-extension-shell-auth/01-03-SUMMARY.md`
</output>
