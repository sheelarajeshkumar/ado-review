---
phase: 02-pr-review-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/types.ts
  - shared/messages.ts
  - shared/storage.ts
  - shared/constants.ts
  - wxt.config.ts
  - entrypoints/options/App.tsx
  - lib/ado-api/types.ts
  - lib/ado-api/client.ts
  - lib/ado-api/pull-requests.ts
  - lib/ado-api/file-content.ts
  - lib/ado-api/threads.ts
  - lib/review/types.ts
  - lib/review/schemas.ts
  - lib/review/file-filter.ts
  - lib/review/retry.ts
  - lib/review/prompt-builder.ts
autonomous: true

must_haves:
  truths:
    - "ADO API client can make authenticated requests to Azure DevOps REST API v7.1"
    - "PR changed files, file content, and PR details can be fetched via typed functions"
    - "Inline and summary comments can be posted to a PR via typed functions"
    - "Non-code files are identified and filtered by extension, filename, and path pattern"
    - "Async functions retry with exponential backoff and jitter on failure"
    - "Zod schemas validate LLM output structure (findings with line, severity, message)"
    - "OpenAI API key can be stored and retrieved from extension storage"
    - "Port message types are defined for review session communication"
  artifacts:
    - path: "lib/ado-api/client.ts"
      provides: "Authenticated fetch wrapper for ADO REST API"
      exports: ["adoFetch", "AdoApiError"]
    - path: "lib/ado-api/pull-requests.ts"
      provides: "PR metadata, iterations, and changed files fetching"
      exports: ["getPrDetails", "getLatestIterationId", "getChangedFiles"]
    - path: "lib/ado-api/file-content.ts"
      provides: "File content retrieval at specific commits"
      exports: ["getFileContent"]
    - path: "lib/ado-api/threads.ts"
      provides: "PR comment thread creation (inline + summary)"
      exports: ["postInlineComment", "postSummaryComment"]
    - path: "lib/ado-api/types.ts"
      provides: "ADO API response type definitions"
    - path: "lib/review/schemas.ts"
      provides: "Zod schemas for LLM output validation"
      exports: ["FindingSchema", "FileReviewSchema", "SummarySchema"]
    - path: "lib/review/file-filter.ts"
      provides: "Non-code file filtering logic"
      exports: ["shouldSkipFile", "shouldSkipByChangeType"]
    - path: "lib/review/retry.ts"
      provides: "Exponential backoff retry utility"
      exports: ["retryWithBackoff"]
    - path: "lib/review/types.ts"
      provides: "Review pipeline type definitions"
    - path: "lib/review/prompt-builder.ts"
      provides: "System and user prompt construction for LLM"
      exports: ["buildSystemPrompt", "buildFileReviewPrompt"]
    - path: "shared/types.ts"
      provides: "Extended types including ReviewProgress"
    - path: "shared/messages.ts"
      provides: "Port message type definitions for review session"
  key_links:
    - from: "lib/ado-api/client.ts"
      to: "lib/auth/manager.ts"
      via: "getAuthHeaders() call"
      pattern: "getAuthHeaders"
    - from: "lib/ado-api/pull-requests.ts"
      to: "lib/ado-api/client.ts"
      via: "adoFetch() calls"
      pattern: "adoFetch"
    - from: "lib/ado-api/threads.ts"
      to: "lib/ado-api/client.ts"
      via: "adoFetch() calls"
      pattern: "adoFetch"
    - from: "lib/review/schemas.ts"
      to: "zod"
      via: "Zod schema definitions"
      pattern: "z\\.object"
    - from: "shared/storage.ts"
      to: "browser.storage.local"
      via: "OpenAI key get/set"
      pattern: "OPENAI_API_KEY"
---

<objective>
Build all foundation modules for the PR review pipeline: ADO API client, review utilities (schemas, file filter, retry, prompts), shared type/message extensions, OpenAI key storage, and manifest update.

Purpose: Provides every building block that the orchestrator (Plan 02-02) and UI (Plan 02-03) depend on. No pipeline logic here -- just composable, independently-correct modules.

Output: 16 files -- `lib/ado-api/*` (5 files), `lib/review/*` (5 files), extended `shared/*` (4 files), updated `wxt.config.ts`, updated `entrypoints/options/App.tsx`
</objective>

<execution_context>
@/Users/81169560/.claude/get-shit-done/workflows/execute-plan.md
@/Users/81169560/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-pr-review-pipeline/02-RESEARCH.md

@shared/types.ts
@shared/messages.ts
@shared/storage.ts
@shared/constants.ts
@lib/auth/manager.ts
@lib/url-matcher.ts
@wxt.config.ts
@entrypoints/options/App.tsx
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and extend shared modules</name>
  <files>
    package.json
    shared/types.ts
    shared/messages.ts
    shared/storage.ts
    shared/constants.ts
    wxt.config.ts
    entrypoints/options/App.tsx
  </files>
  <action>
**Step 1: Install AI SDK packages.**
Run `pnpm add ai @ai-sdk/openai` (project uses pnpm based on pnpm-lock.yaml).

**Step 2: Extend `shared/types.ts`.**
Keep all existing types. Add these new types AFTER the existing AuthStatus interface:

```typescript
/** Progress update sent over the review port. */
export interface ReviewProgress {
  currentFile: string;
  fileIndex: number;
  totalFiles: number;
  status: 'reviewing' | 'posting-comments';
}

/** Result of reviewing a single file. */
export interface FileReviewResult {
  filePath: string;
  status: 'success' | 'error' | 'skipped';
  findingCount?: number;
  error?: string;
}

/** Final review summary sent when all files are done. */
export interface ReviewSummary {
  totalFiles: number;
  reviewedFiles: number;
  skippedFiles: number;
  errorFiles: number;
  totalFindings: number;
  findingsBySeverity: { Critical: number; Warning: number; Info: number };
}
```

**Step 3: Extend `shared/messages.ts`.**
Keep all existing code. Add port message types AFTER the existing `sendMessage` function. These are for the `browser.runtime.connect` port, NOT for `sendMessage`:

```typescript
/** Messages sent over the review port (browser.runtime.connect). */
export type PortMessage =
  | { type: 'START_REVIEW'; payload: { prInfo: PrInfo } }
  | { type: 'REVIEW_PROGRESS'; payload: ReviewProgress }
  | { type: 'REVIEW_FILE_COMPLETE'; payload: FileReviewResult }
  | { type: 'REVIEW_COMPLETE'; payload: ReviewSummary }
  | { type: 'REVIEW_ERROR'; payload: { message: string } };
```

Import `PrInfo`, `ReviewProgress`, `FileReviewResult`, `ReviewSummary` from `@/shared/types`.

**Step 4: Extend `shared/storage.ts`.**
Keep all existing code. Add `OPENAI_API_KEY: 'openai_api_key'` to the STORAGE_KEYS object. Add two new functions after `clearPat`:

```typescript
export async function getOpenAiApiKey(): Promise<string | null> {
  const result = await browser.storage.local.get(STORAGE_KEYS.OPENAI_API_KEY);
  return (result[STORAGE_KEYS.OPENAI_API_KEY] as string) ?? null;
}

export async function setOpenAiApiKey(key: string): Promise<void> {
  await browser.storage.local.set({ [STORAGE_KEYS.OPENAI_API_KEY]: key });
}
```

**Step 5: Extend `shared/constants.ts`.**
Keep all existing constants. Add file filter pattern constants:

```typescript
/** File extensions to skip during review (non-code files). */
export const SKIP_EXTENSIONS = new Set([
  '.lock', '.min.js', '.min.css', '.bundle.js', '.map',
  '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', '.bmp', '.webp',
  '.woff', '.woff2', '.ttf', '.eot', '.otf',
  '.exe', '.dll', '.so', '.dylib', '.bin', '.dat',
  '.pdf', '.doc', '.docx', '.xls', '.xlsx',
  '.zip', '.tar', '.gz', '.rar',
]);

/** Exact filenames to skip during review. */
export const SKIP_FILENAMES = new Set([
  'package-lock.json', 'pnpm-lock.yaml', 'yarn.lock',
  'composer.lock', 'Gemfile.lock', 'Cargo.lock', 'poetry.lock',
  '.DS_Store', 'Thumbs.db',
]);

/** Path patterns to skip during review. */
export const SKIP_PATH_PATTERNS = [
  /node_modules\//,
  /vendor\//,
  /\.generated\//,
  /dist\//,
  /build\//,
  /\.next\//,
];
```

**Step 6: Update `wxt.config.ts`.**
Add `'https://api.openai.com/*'` to the `host_permissions` array.

**Step 7: Update `entrypoints/options/App.tsx`.**
Add an "OpenAI API Key" section AFTER the existing auth section. Import `getOpenAiApiKey` and `setOpenAiApiKey` from `@/shared/storage`. Add state for `apiKey` (string) and `apiKeyFeedback`. On mount (in the existing useEffect), also call `getOpenAiApiKey()` to populate the field. Add a form with a password input and save button that calls `setOpenAiApiKey`. Keep the exact same styling patterns used in the PAT form (className conventions, feedback display). The section heading should be "LLM Configuration" with subheading "OpenAI API Key". Include a brief description: "Enter your OpenAI API key for AI-powered code reviews."
  </action>
  <verify>
Run `pnpm exec tsc --noEmit` -- must pass with no type errors. Verify `ai` and `@ai-sdk/openai` appear in package.json dependencies. Verify `wxt.config.ts` has three host_permissions entries.
  </verify>
  <done>
AI SDK packages installed. shared/types.ts has ReviewProgress, FileReviewResult, ReviewSummary. shared/messages.ts has PortMessage union. shared/storage.ts has OpenAI key get/set. shared/constants.ts has filter pattern sets. wxt.config.ts has api.openai.com host permission. Options page has OpenAI API key input field. All type-checks pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ADO API client module</name>
  <files>
    lib/ado-api/types.ts
    lib/ado-api/client.ts
    lib/ado-api/pull-requests.ts
    lib/ado-api/file-content.ts
    lib/ado-api/threads.ts
  </files>
  <action>
**Create `lib/ado-api/types.ts`:**
Define TypeScript interfaces for ADO REST API responses. These are NOT shared types -- they represent raw API response shapes:

```typescript
/** ADO Pull Request response (GET /pullRequests/{id}). */
export interface AdoPullRequest {
  pullRequestId: number;
  title: string;
  description: string;
  repository: { id: string; name: string };
  lastMergeSourceCommit: { commitId: string };
  lastMergeTargetCommit: { commitId: string };
}

/** Simplified PR details extracted from AdoPullRequest. */
export interface PrDetails {
  sourceCommitId: string;
  targetCommitId: string;
  title: string;
  description: string;
  repositoryId: string;
}

/** ADO Iteration (from iterations list endpoint). */
export interface AdoIteration {
  id: number;
  createdDate: string;
}

/** ADO Iteration Change entry. */
export interface IterationChange {
  changeTrackingId: number;
  changeId: number;
  item: { objectId: string; path: string };
  changeType: number; // VersionControlChangeType enum
}

/** Maps ADO changeType numbers to readable strings. */
export const CHANGE_TYPE_MAP: Record<number, string> = {
  1: 'add',
  2: 'edit',
  16: 'delete',
  8: 'rename',
};

/** ADO CommentPosition (line + offset). */
export interface CommentPosition {
  line: number;
  offset: number;
}

/** ADO ThreadContext for inline comments. */
export interface ThreadContext {
  filePath: string;
  rightFileStart: CommentPosition;
  rightFileEnd: CommentPosition;
}
```

**Create `lib/ado-api/client.ts`:**
Thin authenticated fetch wrapper. Uses `getAuthHeaders` from `@/lib/auth/manager`. Uses `ADO_API_VERSION` from `@/shared/constants`.

- `adoFetch(url: string, options?: RequestInit): Promise<Response>` -- calls `getAuthHeaders` with the org URL extracted from the full URL. Adds `Accept: application/json` header. Merges auth headers. Appends `api-version` query param if not present. Sets `credentials: 'include'` when auth method is `session`. Throws `AdoApiError` on non-ok response.
- Extract org URL by parsing `https://dev.azure.com/{org}` from the full URL (take the first 4 path segments of origin + path).
- `AdoApiError` class extends Error with `status: number`, `body: string`, `url: string` properties.

Follow the exact pattern from research file Pattern 4. The function signature must accept the FULL API URL (callers build URLs using PrInfo.baseUrl).

**Create `lib/ado-api/pull-requests.ts`:**
Three exported async functions using `adoFetch` and `PrInfo` from `@/shared/types`:

1. `getPrDetails(prInfo: PrInfo): Promise<PrDetails>` -- GET `{baseUrl}/_apis/git/repositories/{repo}/pullRequests/{prId}`. Return mapped PrDetails.

2. `getLatestIterationId(prInfo: PrInfo): Promise<number>` -- GET `{baseUrl}/_apis/git/repositories/{repo}/pullRequests/{prId}/iterations`. Return `Math.max(...iterations.map(i => i.id))`.

3. `getChangedFiles(prInfo: PrInfo, iterationId: number): Promise<IterationChange[]>` -- GET `{baseUrl}/_apis/git/repositories/{repo}/pullRequests/{prId}/iterations/{iterationId}/changes` with `$top=100` pagination. Loop while `changeEntries.length === top`, incrementing `$skip`. Return all changes concatenated.

Import types from `./types`. Use `buildApiUrl` from `@/lib/url-matcher` OR construct URLs directly from `prInfo.baseUrl` -- either works, but be consistent with the research pattern (direct construction).

**Create `lib/ado-api/file-content.ts`:**
One exported function:

`getFileContent(prInfo: PrInfo, filePath: string, commitId: string): Promise<string>` -- GET `{baseUrl}/_apis/git/repositories/{repo}/items` with query params: `path` (URL-encoded), `includeContent=true`, `versionDescriptor.version={commitId}`, `versionDescriptor.versionType=commit`, `$format=json`. Parse response JSON and return `data.content ?? ''`.

**Create `lib/ado-api/threads.ts`:**
Two exported functions:

1. `postInlineComment(prInfo: PrInfo, filePath: string, finding: Finding, iterationId: number): Promise<void>` -- POST to `{baseUrl}/_apis/git/repositories/{repo}/pullRequests/{prId}/threads`. Body includes: `comments` array with single comment (parentCommentId: 0, content with severity tag + message + optional suggestion, commentType: 1), `status: 1`, `threadContext` with `filePath` (ensure leading `/`), `rightFileStart: { line: finding.line, offset: 1 }`, `rightFileEnd: { line: finding.line, offset: 1000 }`. Import `Finding` type from `@/lib/review/schemas`.

2. `postSummaryComment(prInfo: PrInfo, summaryMarkdown: string): Promise<void>` -- POST to same URL. Body includes: `comments` array with single comment (content: summaryMarkdown, commentType: 1), `status: 1`. NO `threadContext` (PR-level comment).

Both functions add `Content-Type: application/json` header and set method to `POST`.

Format inline comment content as: `**[{severity}]** {message}` on first line. If suggestion exists, add `\n\n**Suggestion:** {suggestion}` on next line.

Add a small delay helper: `postInlineComment` should NOT handle rate limiting itself -- the orchestrator handles pacing. But DO add a 150ms delay between posts via a module-level `lastPostTime` tracker and `await sleep(Math.max(0, 150 - elapsed))` before each POST. This prevents rate limiting on rapid sequential calls (Pitfall 6 from research).
  </action>
  <verify>
Run `pnpm exec tsc --noEmit` -- must pass with no type errors. Verify all 5 files exist under `lib/ado-api/`. Verify `client.ts` imports from `@/lib/auth/manager`. Verify `threads.ts` imports `Finding` from `@/lib/review/schemas`.
  </verify>
  <done>
Five ADO API files created. client.ts provides authenticated fetch with session credential handling. pull-requests.ts fetches PR details, iterations, and changed files with pagination. file-content.ts fetches file content at specific commits. threads.ts posts inline and summary comments with proper threadContext positioning. All functions use adoFetch and handle the ADO REST API v7.1 contract. Type-checks pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create review utility modules</name>
  <files>
    lib/review/types.ts
    lib/review/schemas.ts
    lib/review/file-filter.ts
    lib/review/retry.ts
    lib/review/prompt-builder.ts
  </files>
  <action>
**Create `lib/review/types.ts`:**
Internal types for the review pipeline (NOT shared -- these are for lib/review/ internal use):

```typescript
import type { PrInfo } from '@/shared/types';
import type { PrDetails, IterationChange } from '@/lib/ado-api/types';

/** Input context for a review session. */
export interface ReviewContext {
  prInfo: PrInfo;
  prDetails: PrDetails;
  iterationId: number;
  changes: IterationChange[];
  apiKey: string;
}

/** A file prepared for LLM review (after filtering and content fetch). */
export interface ReviewableFile {
  path: string;
  content: string;
  changeType: string; // 'add' | 'edit' | 'rename'
}

/** Result of the LLM reviewing a single file (internal, richer than FileReviewResult). */
export interface SingleFileResult {
  filePath: string;
  status: 'success' | 'error' | 'skipped';
  findings: import('./schemas').Finding[];
  fileSummary: string;
  error?: string;
}
```

**Create `lib/review/schemas.ts`:**
Zod schemas for structured LLM output. Import `z` from `zod`.

```typescript
export const FindingSchema = z.object({
  line: z.number().describe('The line number in the file where the issue is'),
  severity: z.enum(['Critical', 'Warning', 'Info']).describe('Issue severity'),
  message: z.string().describe('Clear description of the issue found'),
  suggestion: z.string().optional().describe('Suggested fix or improvement'),
});

export const FileReviewSchema = z.object({
  findings: z.array(FindingSchema).describe('List of issues found in this file'),
  summary: z.string().describe('One-sentence summary of this file review'),
});

export type Finding = z.infer<typeof FindingSchema>;
export type FileReview = z.infer<typeof FileReviewSchema>;
```

Also add a `SummaryInputSchema` for validating the summary generation input (not LLM output -- just a utility type):
```typescript
export const SummaryInputSchema = z.object({
  filePath: z.string(),
  summary: z.string(),
  findingCount: z.number(),
  criticalCount: z.number(),
  warningCount: z.number(),
  infoCount: z.number(),
});
export type SummaryInput = z.infer<typeof SummaryInputSchema>;
```

**Create `lib/review/file-filter.ts`:**
Uses the constants from `@/shared/constants` (SKIP_EXTENSIONS, SKIP_FILENAMES, SKIP_PATH_PATTERNS). Two exported functions:

1. `shouldSkipFile(filePath: string): boolean` -- Extract filename from path (split on `/`, take last). Extract extension (handle multi-dot like `.min.js` by checking the last `.xxx` segment AND the last two segments joined). Check against SKIP_FILENAMES set, SKIP_EXTENSIONS set, and SKIP_PATH_PATTERNS regex array. Return true if ANY match.

2. `shouldSkipByChangeType(changeType: string): boolean` -- Return true if changeType is `'delete'`. Deleted files have no code to review.

For multi-part extensions: check both `.js` AND `.min.js` by looking at whether the filename contains `.min.` or `.bundle.`. Simple approach: after checking single extension, also check if filename ends with any SKIP_EXTENSIONS entry using `fileName.endsWith(ext)`.

**Create `lib/review/retry.ts`:**
Implements CORE-06. One exported function:

```typescript
export interface RetryOptions {
  maxRetries: number;
  baseDelayMs: number;
  maxDelayMs?: number;
}

export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  options: RetryOptions,
): Promise<T>
```

Logic: Loop from attempt 0 to maxRetries. On each attempt, try `fn()`. If it throws and we have retries left, compute delay as `min(baseDelayMs * 2^attempt + random(0-1000), maxDelayMs ?? 30000)`, then `await new Promise(r => setTimeout(r, delay))`. If final attempt throws, rethrow the error. Log retry attempts with `console.warn('[PEP Review] Retry attempt ${attempt + 1}/${maxRetries}')`.

**Create `lib/review/prompt-builder.ts`:**
Two exported functions:

1. `buildSystemPrompt(): string` -- Returns the system prompt from the research file. Focus areas: bugs/logic errors, security vulnerabilities, performance issues, error handling gaps, maintainability. Explicitly tell LLM NOT to comment on formatting/whitespace or subjective style. Tell it to be concise and only report genuine issues.

2. `buildFileReviewPrompt(filePath: string, fileContent: string, changeType: string): string` -- Returns a user prompt with file path, change type context (new vs changed), and the file content in a code block. Include clear instruction: "Analyze the code above and report any issues found. If no issues are found, return an empty findings array with a brief positive summary." Include the line number context: "Line numbers in your findings must correspond to line numbers in the code block above."

Add line numbers to the code block content: prepend each line with its 1-based line number (e.g., `  1 | import foo from 'bar';`). This helps the LLM report accurate line numbers (addresses Pitfall 3 from research).
  </action>
  <verify>
Run `pnpm exec tsc --noEmit` -- must pass with no type errors. Verify all 5 files exist under `lib/review/`. Verify `schemas.ts` exports FindingSchema, FileReviewSchema, Finding, FileReview. Verify `file-filter.ts` imports from `@/shared/constants`. Verify `retry.ts` exports retryWithBackoff.
  </verify>
  <done>
Five review utility files created. schemas.ts defines Zod-validated Finding and FileReview types for LLM output. file-filter.ts skips non-code files by extension, filename, path pattern, and change type. retry.ts provides exponential backoff with jitter (CORE-06). prompt-builder.ts builds system and file review prompts with line-numbered code blocks. types.ts defines internal pipeline types. All type-checks pass.
  </done>
</task>

</tasks>

<verification>
After all three tasks complete:

1. `pnpm exec tsc --noEmit` passes with zero errors
2. `lib/ado-api/` has 5 files: types.ts, client.ts, pull-requests.ts, file-content.ts, threads.ts
3. `lib/review/` has 5 files: types.ts, schemas.ts, file-filter.ts, retry.ts, prompt-builder.ts
4. `shared/types.ts` exports ReviewProgress, FileReviewResult, ReviewSummary
5. `shared/messages.ts` exports PortMessage type
6. `shared/storage.ts` exports getOpenAiApiKey, setOpenAiApiKey
7. `shared/constants.ts` exports SKIP_EXTENSIONS, SKIP_FILENAMES, SKIP_PATH_PATTERNS
8. `wxt.config.ts` includes api.openai.com in host_permissions
9. `package.json` includes `ai` and `@ai-sdk/openai` as dependencies
</verification>

<success_criteria>
All 16 files exist and pass type checking. Every module is independently importable -- no circular dependencies. The ADO API client integrates with existing auth module. Review schemas validate with Zod. Foundation is ready for Plan 02-02 (orchestrator + LLM reviewer) to build on top.
</success_criteria>

<output>
After completion, create `.planning/phases/02-pr-review-pipeline/02-01-SUMMARY.md`
</output>
